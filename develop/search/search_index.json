{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#argo-gtfs_skims","title":"Argo (gtfs_skims)","text":"<p>Argo is a library aimed at the fast calculation of generalised time matrices from GTFS files. By applying appropriate simplifications on the GTFS dataset, the library is able to calculate such matrices at scale. For example, it was possible to calculate an MSOA-to-MSOA matrix for England and Wales in ~1 hour (with a relatively large machine).</p>"},{"location":"contributing/","title":"Contributing","text":"<p>gtfs_skims is an actively maintained and utilised project.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>to report issues, request features, or exchange with our community, just follow the links below.</p> <p>Is something not working?</p> <p> Report a bug</p> <p>Missing information in our docs?</p> <p> Report a docs issue</p> <p>Want to submit an idea?</p> <p> Request a change</p> <p>Have a question or need help?</p> <p> Ask a question</p>"},{"location":"contributing/#developing-gtfs_skims","title":"Developing gtfs_skims","text":"<p>To find beginner-friendly existing bugs and feature requests you may like to start out with, take a look at our good first issues.</p>"},{"location":"contributing/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To create a development environment for gtfs_skims, with all libraries required for development and quality assurance installed, it is easiest to install gtfs_skims using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the gtfs_skims repository: <code>git clone git@github.com:arup-group/gtfs_skims.git</code></li> <li>Change into the <code>gtfs_skims</code> directory: <code>cd gtfs_skims</code></li> <li>Create the gtfs_skims mamba environment: <code>mamba create -n gtfs_skims -c conda-forge --file requirements/base.txt --file requirements/dev.txt</code></li> <li>Activate the gtfs_skims mamba environment: <code>mamba activate gtfs_skims</code></li> <li>Install the gtfs_skims package into the environment, in editable mode and ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps -e .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/gtfs_skims.git\ncd gtfs_skims\nmamba create -n gtfs_skims -c conda-forge --file requirements/base.txt --file requirements/dev.txt\nmamba activate gtfs_skims\npip install --no-deps -e .\n</code></pre> <p>If installing directly with pip, you can install these libraries using the <code>dev</code> option, i.e., <code>pip install -e '.[dev]'</code></p> <p>If you plan to make changes to the code then please make regular use of the following tools to verify the codebase while you work:</p> <ul> <li><code>pre-commit</code>: run <code>pre-commit install</code> in your command line to load inbuilt checks that will run every time you commit your changes. The checks are: 1. check no large files have been staged, 2. lint python files for major errors, 3. format python files to conform with the PEP8 standard. You can also run these checks yourself at any time to ensure staged changes are clean by calling <code>pre-commit</code>.</li> <li><code>pytest</code> - run the unit test suite and check test coverage.</li> </ul>"},{"location":"contributing/#rapid-fire-testing","title":"Rapid-fire testing","text":"<p>The following options allow you to strip down the test suite to the bare essentials: 1. You can avoid generating coverage reports, by adding the <code>--no-cov</code> argument: <code>pytest --no-cov</code>. 1. By default, the tests run with up to two parallel threads, to increase this to e.g. 4 threads: <code>pytest -n4</code>.</p> <p>All together:</p> <pre><code>pytest tests/ --no-cov -n4\n</code></pre> <p>Note</p> <p>You cannot debug failing tests and have your tests run in parallel, you will need to set <code>-n0</code> if using the <code>--pdb</code> flag</p>"},{"location":"contributing/#memory-profiling","title":"Memory profiling","text":"<p>Note</p> <p>When you open a pull request (PR), one of the GitHub actions will run memory profiling for you. This means you don't have to do any profiling locally. However, if you can, it is still good practice to do so as you will catch issues earlier.</p> <p>gtfs_skims can be memory intensive; we like to ensure that any development to the core code does not exacerbate this. If you are running on a UNIX device (i.e., not on Windows), you can test whether any changes you have made adversely impact memory and time performance as follows:</p> <ol> <li>Install memray in your <code>gtfs_skims</code> mamba environment: <code>mamba install memray pytest-memray</code>.</li> <li>Run the memory profiling integration test: <code>pytest -p memray -m \"high_mem\" --no-cov</code>.</li> <li>Optionally, to visualise the memory allocation, run <code>pytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]</code> - where you must define <code>[my_path]</code> and <code>[my_prefix]</code> - followed by <code>memray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_mem.bin</code>. You will then find the HTML report at <code>[my_path]/memray-flamegraph-[my_prefix]-tests-test_100_memory_profiling.py-test_mem.html</code>.</li> </ol> <p>All together:</p> <pre><code>mamba install memray pytest-memray\npytest -p memray -m \"high_mem\" --no-cov --memray-bin-path=[my_path] --memray-bin-prefix=[my_prefix]\nmemray flamegraph [my_path]/[my_prefix]-tests-test_100_memory_profiling.py-test_mem.bin\n</code></pre> <p>For more information on using memray, refer to their documentation.</p>"},{"location":"contributing/#updating-the-project-when-the-template-updates","title":"Updating the project when the template updates","text":"<p>This project has been built with cruft based on the Arup Cookiecutter template. When changes are made to the base template, they can be merged into this project by running <code>cruft update</code> from the  <code>gtfs_skims</code> mamba environment.</p> <p>You may be prompted to do this when you open a Pull Request, if our automated checks identify that the template is newer than that used in the project.</p>"},{"location":"contributing/#submitting-changes","title":"Submitting changes","text":"<p>To contribute changes:</p> <ol> <li>Fork the project on GitHub.</li> <li>Create a feature branch to work on in your fork (<code>git checkout -b new-fix-or-feature</code>).</li> <li>Test your changes using <code>pytest</code>.</li> <li>Commit your changes to the feature branch (you should have <code>pre-commit</code> installed to ensure your code is correctly formatted when you commit changes).</li> <li>Push the branch to GitHub (<code>git push origin new-fix-or-feature</code>).</li> <li>On GitHub, create a new pull request from the feature branch.</li> </ol>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Before submitting a pull request, check whether you have:</p> <ul> <li>Added your changes to <code>CHANGELOG.md</code>.</li> <li>Added or updated documentation for your changes.</li> <li>Added tests if you implemented new functionality.</li> </ul> <p>When opening a pull request, please provide a clear summary of your changes!</p>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>Please try to write clear commit messages. One-line messages are fine for small changes, but bigger changes should look like this:</p> <pre><code>A brief summary of the commit (max 50 characters)\n\nA paragraph or bullet-point list describing what changed and its impact,\ncovering as many lines as needed.\n</code></pre>"},{"location":"contributing/#code-conventions","title":"Code conventions","text":"<p>Start reading our code and you'll get the hang of it.</p> <p>We mostly follow the official Style Guide for Python Code (PEP8).</p> <p>We have chosen to use the uncompromising code formatter <code>black</code> and the linter <code>ruff</code>. When run from the root directory of this repo, <code>pyproject.toml</code> should ensure that formatting and linting fixes are in line with our custom preferences (e.g., 100 character maximum line length). The philosophy behind using <code>black</code> is to have uniform style throughout the project dictated by code. Since <code>black</code> is designed to minimise diffs, and make patches more human readable, this also makes code reviews more efficient. To make this a smooth experience, you should run <code>pre-commit install</code> after setting up your development environment, so that <code>black</code> makes all the necessary fixes to your code each time you commit, and so that <code>ruff</code> will highlight any errors in your code. If you prefer, you can also set up your IDE to run these two tools whenever you save your files, and to have <code>ruff</code> highlight erroneous code directly as you type. Take a look at their documentation for more information on configuring this.</p> <p>We require all new contributions to have docstrings for all modules, classes and methods. When adding docstrings, we request you use the Google docstring style.</p>"},{"location":"contributing/#release-checklist","title":"Release checklist","text":""},{"location":"contributing/#pre-release","title":"Pre-release","text":"<ul> <li> Make sure all unit and integration tests pass (This is best done by creating a pre-release pull request).</li> <li> Re-run tutorial Jupyter notebooks (<code>pytest examples/ --overwrite</code>).</li> <li> Make sure documentation builds without errors (<code>mike deploy [version]</code>, where <code>[version]</code> is the current minor release of the form <code>X.Y</code>).</li> <li> Make sure the changelog is up-to-date, especially that new features and backward incompatible changes are clearly marked.</li> </ul>"},{"location":"contributing/#create-release","title":"Create release","text":"<ul> <li> Bump the version number in <code>src/gtfs_skims/__init__.py</code></li> <li> Update the changelog with final version number of the form <code>vX.Y.Z</code>, release date, and github <code>compare</code> link (at the bottom of the page).</li> <li> Commit with message <code>Release vX.Y.Z</code>, then add a <code>vX.Y.Z</code> tag.</li> <li> Once the PR is approved and merged, create a release through the GitHub web interface, using the same tag, titling it <code>Release vX.Y.Z</code> and include all the changelog elements that are not flagged as internal.</li> </ul>"},{"location":"contributing/#post-release","title":"Post-release","text":"<ul> <li> Update the changelog, adding a new <code>[Unreleased]</code> heading.</li> <li> Update <code>src/gtfs_skims/__init__.py</code> to the next version appended with <code>.dev0</code>, in preparation for the next main commit.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Note: this library only supports Unix-based systems (ie Ubuntu/macOS). If you wish to use it on Windows please use the Windows Subsystem for Linux.</p>"},{"location":"installation/#setting-up-a-user-environment","title":"Setting up a user environment","text":"<p>As a <code>gtfs_skims</code> user, it is easiest to install using the mamba package manager, as follows:</p> <ol> <li>Install mamba with the Mambaforge executable for your operating system.</li> <li>Open the command line (or the \"miniforge prompt\" in Windows).</li> <li>Download (a.k.a., clone) the gtfs_skims repository: <code>git clone git@github.com:arup-group/gtfs_skims.git</code></li> <li>Change into the <code>gtfs_skims</code> directory: <code>cd gtfs_skims</code></li> <li>Create the gtfs_skims mamba environment: <code>mamba create -n gtfs_skims -c conda-forge -c city-modelling-lab --file requirements/base.txt</code></li> <li>Activate the gtfs_skims mamba environment: <code>mamba activate gtfs_skims</code></li> <li>Install the gtfs_skims package into the environment, ignoring dependencies (we have dealt with those when creating the mamba environment): <code>pip install --no-deps .</code></li> </ol> <p>All together:</p> <pre><code>git clone git@github.com:arup-group/gtfs_skims.git\ncd gtfs_skims\nmamba create -n gtfs_skims -c conda-forge --file requirements/base.txt\nmamba activate gtfs_skims\npip install --no-deps .\n</code></pre>"},{"location":"installation/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The install instructions are slightly different to create a development environment compared to a user environment:</p> <pre><code>git clone git@github.com:arup-group/gtfs_skims.git\ncd gtfs_skims\nmamba create -n gtfs_skims -c conda-forge --file requirements/base.txt --file requirements/dev.txt\nmamba activate gtfs_skims\npip install --no-deps -e .\n</code></pre> <p>For more detailed installation instructions specific to developing the gtfs_skims codebase, see our development documentation.</p>"},{"location":"methodology/","title":"Methodology","text":"<p>Argo calculates generalised time matrices between a set of origin and destination points.</p> <p>Generalised time is defined as follows:</p> \\[ gc = ivt + \\beta_{wait} \\cdot wait\\_time + \\beta_{walk} \\cdot walk\\_time + \\beta_{interchange\\_penalty} \\cdot n\\_transfers \\] <p>Some example values for the leg component weights are: </p> \\[ \\beta_{wait} = \\beta_{walk} \\sim 2 \\text{ to } 3 \\\\ \\beta_{interchange\\_penalty} \\sim 5 \\text{ to } 10 \\text{ minutes} \\] <p>Walk distance is calculated as the crow's fly distance between two points, multiplied by a factor specified in the config file (typically ~1.3).</p> <p>The library creates a graph representation of the GTFS dataset, where the edges represent vehicle movements or connections (access/egress/transfer legs). It then applied a shortest-paths algorithm, using generalised time as edge weights.</p> <p>To achieve high performance, the user can limit the search space by:</p> <ul> <li> <p>selecting a time scope and maximum travel time</p> </li> <li> <p>selecting a specific day</p> </li> <li> <p>selecting a maximum walk, wait and trasfer time for legs</p> </li> <li> <p>applying a spatial bounding box</p> </li> </ul> <p>We further improve performance by:</p> <ul> <li> <p>using K-dimensional trees to organise spatial data</p> </li> <li> <p>using the effiecient graph-tool library to calculate shortest distances</p> </li> <li> <p>parallelising the shortest distances calculation, and vectorising data transformation tasks</p> </li> <li> <p>saving files to a compressed parquet format</p> </li> </ul>"},{"location":"run/","title":"Running Argo","text":"<p>To run argo simply type this command on the command line: <pre><code>gtfs_skims run &lt;CONFIG_PATH&gt;\n</code></pre> , where  is the path to the config yaml file. <p>An example config file is shown below: <pre><code>paths:\n  path_gtfs: ./tests/test_data/iow-bus-gtfs.zip\n  path_outputs: ./tests/test_data/outputs\n  path_origins: ./tests/test_data/centroids.csv # path to the origin points\n  path_destinations: ./tests/test_data/centroids.csv # path to the destination points\n\nsettings:\n  calendar_date : 20190515 # yyyymmdd | Date for filtering the GTFS file.\n  start_s : 32400 # sec | Start time of the journey.\n  end_s : 41400 # sec | Max end time of a journey.\n  walk_distance_threshold : 2000  # m | Max walk distance in a leg\n  walk_speed : 4.5  # kph | Walking speed\n  crows_fly_factor : 1.3 # Conversion factor from euclidean to routed distances\n  max_transfer_time : 1800 # Max combined time of walking and waiting (sec) of a transfer\n  max_wait : 1800  # sec | Max wait time at a stop / leg\n  bounding_box : null\n  epsg_centroids: 27700 # coordinate system of the centroids file. Needs to be Cartesian and in meters.\n  weight_walk: 2 # value of walk time, ratio to in-vehicle time\n  weight_wait: 2 # value of wait time, ratio to in-vehicle time\n  penalty_interchange: 300 # seconds added to generalised cost for each interchange\n\nsteps:\n  - preprocessing\n  - connectors\n  - graph\n</code></pre></p> <p>More information about the config can be found in the schema definition here.</p> <p>To run the example provided by the repo, use: <pre><code>gtfs_skims run ./tests/test_data/config_demo.yaml\n</code></pre></p> <p>The time matrices will be saved in the <code>output_path</code> directory defined in the config file, in the <code>skims.parquet.gzip</code> file. An easy way to read the file is with pandas: <pre><code>import pandas as pd\ndf = pd.read_parquet('&lt;OUTPUT_PATH&gt;/skims.parquet.gzip')\ndf\n</code></pre></p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides documentation for our command line tools.</p>"},{"location":"api/cli/#gtfs_skims","title":"gtfs_skims","text":"<p>Console script for Argo (gtfs_skims).</p> <p>Usage:</p> <pre><code>gtfs_skims [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"api/cli/#gtfs_skims-run","title":"gtfs_skims run","text":"<p>Usage:</p> <pre><code>gtfs_skims run [OPTIONS] CONFIG_PATH\n</code></pre> <p>Options:</p> Name Type Description Default <code>--output_directory_override</code> text override output directory None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li> <p>documentation updates.</p> </li> <li> <p>Render math in documentation #3.</p> </li> <li>Remove CI badges from showing in documentation index page (they do not render in non-public repositories).</li> </ul>"},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li> <p>yaml schema file.</p> </li> <li> <p>Links to external objects in documented Python API.</p> </li> <li>internal PyPI upload option.</li> </ul>"},{"location":"CHANGELOG/#v010-2023-12-13","title":"[v0.1.0] - 2023-12-13","text":"<p>Initial release.</p>"},{"location":"reference/gtfs_skims/connectors/","title":"gtfs_skims.connectors","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors","title":"<code>AccessEgressConnectors(coords_origins, coords_destinations, max_transfer_distance)</code>","text":"<p>             Bases: <code>TransferConnectors</code></p> <p>Connections between zones/endpoints and stops</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def __init__(\n    self,\n    coords_origins: np.ndarray,\n    coords_destinations: np.ndarray,\n    max_transfer_distance: float,\n) -&gt; None:\n    self.coords_origins = coords_origins\n    self.coords_destinations = coords_destinations\n\n    radius = max_transfer_distance\n    if coords_origins.shape[1] == 3:\n        radius += max_transfer_distance * (2**0.5)\n\n    self.ods = query_pairs_od(coords_origins, coords_destinations, radius=radius)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors.coords_destinations","title":"<code>coords_destinations = coords_destinations</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors.coords_origins","title":"<code>coords_origins = coords_origins</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors.dcoords","title":"<code>dcoords: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Destination coordinates.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: x, y (,z)</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors.ocoords","title":"<code>ocoords: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Origin coordinates.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: x, y (, z)</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.AccessEgressConnectors.ods","title":"<code>ods = query_pairs_od(coords_origins, coords_destinations, radius=radius)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors","title":"<code>TransferConnectors(coords, max_transfer_distance)</code>","text":"<p>Manages transfer connectors.</p> PARAMETER  DESCRIPTION <code>coords</code> <p>Point coordinates (x, y, z)</p> <p> TYPE: <code>ndarray</code> </p> <code>max_transfer_distance</code> <p>Maximum distance between points</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def __init__(self, coords: np.ndarray, max_transfer_distance: float) -&gt; None:\n    \"\"\"Manages transfer connectors.\n\n    Args:\n        coords (np.ndarray): Point coordinates (x, y, z)\n        max_transfer_distance (float): Maximum distance between points\n    \"\"\"\n    self.coords = coords\n    radius = max_transfer_distance * (2**0.5)\n    self.ods = query_pairs(coords, radius=radius)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.coords","title":"<code>coords = coords</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.dcoords","title":"<code>dcoords: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Destination coordinates.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: x, y, z</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.ocoords","title":"<code>ocoords: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Origin coordinates.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: x, y, z</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.ods","title":"<code>ods = query_pairs(coords, radius=radius)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.wait","title":"<code>wait: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Wait distance. It is calculated as the difference between timestamps (dz)     and the distance required to walk to the destination.</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Wait distance.</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.walk","title":"<code>walk: np.array</code>  <code>cached</code> <code>property</code>","text":"<p>Walk distance (euclidean).</p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Distance from origin to destination point (on the xy axis).</p>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter","title":"<code>filter(cond)</code>","text":"<p>Filter (in-place) Connnectors' origin-destination data based on a set of conditions.</p> PARAMETER  DESCRIPTION <code>cond</code> <p>The boolean condition filter to use.</p> <p> TYPE: <code>array[bool]</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter(self, cond: np.ndarray[bool]) -&gt; None:\n    \"\"\"Filter (in-place) Connnectors' origin-destination data based on a set of conditions.\n\n    Args:\n        cond np.array[bool]: The boolean condition filter to use.\n    \"\"\"\n    ods = self.ods\n    ocoords = self.ocoords\n    dcoords = self.dcoords\n    walk = self.walk\n    wait = self.wait\n\n    self.ods = ods[cond]\n    self.ocoords = ocoords[cond]\n    self.dcoords = dcoords[cond]\n    self.walk = walk[cond]\n    self.wait = wait[cond]\n\n    return self\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter_feasible_transfer","title":"<code>filter_feasible_transfer(maxdist)</code>","text":"<p>Remove any connections with insufficient transfer time.</p> PARAMETER  DESCRIPTION <code>maxdist</code> <p>Maximum transfer distance (walk+wait)</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter_feasible_transfer(self, maxdist: float) -&gt; None:\n    \"\"\"Remove any connections with insufficient transfer time.\n\n\n    Args:\n        maxdist (float): Maximum transfer distance (walk+wait)\n    \"\"\"\n    is_feasible = (self.wait &gt; 0) &amp; ((self.walk + self.wait) &lt;= maxdist)\n    self.filter(is_feasible)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter_max_wait","title":"<code>filter_max_wait(max_wait)</code>","text":"<p>Remove any connections beyond a wait distance threshold.</p> PARAMETER  DESCRIPTION <code>max_wait</code> <p>Maximum stop (leg) wait time.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter_max_wait(self, max_wait: float) -&gt; None:\n    \"\"\"Remove any connections beyond a wait distance threshold.\n\n    Args:\n        max_wait (float): Maximum stop (leg) wait time.\n    \"\"\"\n    self.filter(self.wait &lt;= max_wait)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter_max_walk","title":"<code>filter_max_walk(max_walk)</code>","text":"<p>Remove any connections beyond a walk-distance threshold.</p> PARAMETER  DESCRIPTION <code>max_walk</code> <p>Max walk distance</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter_max_walk(self, max_walk: float) -&gt; None:\n    \"\"\"Remove any connections beyond a walk-distance threshold.\n\n    Args:\n        max_walk (float): Max walk distance\n    \"\"\"\n    cond = self.walk &lt;= max_walk\n    self.filter(cond)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter_nearest_service","title":"<code>filter_nearest_service(services)</code>","text":"<p>If a service can be accessed from a origin through multiple stops,     then only keep the most efficient transfer for that connection.</p> PARAMETER  DESCRIPTION <code>services</code> <p>Service IDs array. Its indexing must match the self.coords table.</p> <p> TYPE: <code>array</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter_nearest_service(self, services: np.ndarray) -&gt; None:\n    \"\"\"If a service can be accessed from a origin through multiple stops,\n        then only keep the most efficient transfer for that connection.\n\n    Args:\n        services (np.array): Service IDs array. Its indexing must match the self.coords table.\n    \"\"\"\n    services_d = services[self.ods[:, 1]]  # destination service\n\n    # sort by trasfer distance\n    transfer = self.wait + self.walk\n    idx_sorted = transfer.argsort()\n\n    # create origin-service combinations\n    order_o = int(np.floor(np.log10(services.max())) + 1)\n    comb = (self.ods[:, 0] + 1) * 10**order_o + services_d\n\n    # get first instance of each origin-service combination\n    # (which corresponds to the most efficient transfer)\n    keep = idx_sorted[np.unique(comb[idx_sorted], return_index=True)[1]]\n    cond = np.isin(np.arange(len(comb)), keep)\n\n    self.filter(cond)\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.TransferConnectors.filter_same_route","title":"<code>filter_same_route(routes)</code>","text":"<p>Remove connections between services of the same route.</p> PARAMETER  DESCRIPTION <code>routes</code> <p>Route IDs array. Its indexing matches the self.coords table.</p> <p> TYPE: <code>array</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def filter_same_route(self, routes: np.ndarray) -&gt; None:\n    \"\"\"Remove connections between services of the same route.\n\n    Args:\n        routes (np.array): Route IDs array. Its indexing matches the self.coords table.\n    \"\"\"\n    self.filter(routes[self.ods[:, 0]] != routes[self.ods[:, 1]])\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.get_access_connectors","title":"<code>get_access_connectors(data, config, origins)</code>","text":"<p>Get all access connectors (between origins and stops).</p> PARAMETER  DESCRIPTION <code>data</code> <p>GTFS data object.</p> <p> TYPE: <code>GTFSData</code> </p> <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> <code>origins</code> <p>Origin coordinates dataframe. Must include 'x' and 'y' columns, providing the cartesian coordinates of the trip start points.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: [origin id, destination id, walk time, wait time]</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def get_access_connectors(data: GTFSData, config: Config, origins: pd.DataFrame) -&gt; np.ndarray:\n    \"\"\"Get all access connectors (between origins and stops).\n\n    Args:\n        data (GTFSData): GTFS data object.\n        config (Config): Config object.\n        origins (pd.DataFrame):\n            Origin coordinates dataframe.\n            Must include 'x' and 'y' columns, providing the cartesian coordinates of the trip start points.\n\n    Returns:\n        np.ndarray: [origin id, destination id, walk time, wait time]\n    \"\"\"\n    time_to_distance = config.walk_speed / 3.6  # km/hr to meters\n    max_transfer_distance = config.max_transfer_time * time_to_distance\n    max_wait_distance = config.max_wait * time_to_distance\n\n    # get candidate connectors\n    coords_stops = data.stop_times[[\"x\", \"y\", \"departure_s\"]].values\n    coords_stops[:, :2] = coords_stops[:, :2] * config.crows_fly_factor  # crow's fly transformation\n    coords_origins = (origins[[\"x\", \"y\"]] * config.crows_fly_factor).assign(z=config.start_s).values\n\n    ac = AccessEgressConnectors(coords_origins, coords_stops, max_transfer_distance)\n\n    # more narrow filtering\n    ac.filter_feasible_transfer(max_transfer_distance)\n    if config.walk_distance_threshold &lt; max_transfer_distance:\n        ac.filter_max_walk(config.walk_distance_threshold)\n    if max_wait_distance &lt; max_transfer_distance:\n        ac.filter_max_wait(max_wait_distance)\n\n    arr = (\n        np.concatenate(\n            [\n                ac.ods,  # origin and destination index\n                (ac.walk / time_to_distance).reshape(-1, 1),  # walk time (seconds)\n                (ac.wait / time_to_distance).reshape(-1, 1),  # wait time (seconds)\n            ],\n            axis=1,\n        )\n        .round(1)\n        .astype(DATA_TYPE)\n    )\n\n    return arr\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.get_egress_connectors","title":"<code>get_egress_connectors(data, config, destinations)</code>","text":"<p>Get all egress connectors (between stops and destinations).</p> PARAMETER  DESCRIPTION <code>data</code> <p>GTFS data object.</p> <p> TYPE: <code>GTFSData</code> </p> <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> <code>destinations</code> <p>Destination coordinates dataframe. Must include 'x' and 'y' columns, providing the cartesian coordinates of the trip ends.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: [origin id, destination id, walk time, wait time]</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def get_egress_connectors(data: GTFSData, config: Config, destinations: pd.DataFrame) -&gt; np.ndarray:\n    \"\"\"Get all egress connectors (between stops and destinations).\n\n    Args:\n        data (GTFSData): GTFS data object.\n        config (Config): Config object.\n        destinations (pd.DataFrame):\n            Destination coordinates dataframe.\n            Must include 'x' and 'y' columns, providing the cartesian coordinates of the trip ends.\n\n    Returns:\n        np.ndarray: [origin id, destination id, walk time, wait time]\n    \"\"\"\n    time_to_distance = config.walk_speed / 3.6  # km/hr to meters\n\n    # get candidate connectors\n    coords_stops = data.stop_times[[\"x\", \"y\"]].values\n    coords_stops[:, :2] = coords_stops[:, :2] * config.crows_fly_factor  # crow's fly transformation\n    coords_destinations = (destinations[[\"x\", \"y\"]] * config.crows_fly_factor).values\n\n    ec = AccessEgressConnectors(coords_stops, coords_destinations, config.walk_distance_threshold)\n\n    arr = (\n        np.concatenate(\n            [\n                ec.ods,  # origin and destination index\n                (ec.walk / time_to_distance).reshape(-1, 1),  # walk time (seconds)\n                np.array([0] * len(ec.ods)).reshape(-1, 1),  # wait time = 0\n            ],\n            axis=1,\n        )\n        .round(1)\n        .astype(DATA_TYPE)\n    )\n\n    return arr\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.get_transfer_connectors","title":"<code>get_transfer_connectors(data, config)</code>","text":"<p>Get all transfer connectors (between stops).</p> PARAMETER  DESCRIPTION <code>data</code> <p>GTFS data object.</p> <p> TYPE: <code>GTFSData</code> </p> <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.ndarray: [origin id, destination id, walk time, wait time]</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def get_transfer_connectors(data: GTFSData, config: Config) -&gt; np.array:\n    \"\"\"Get all transfer connectors (between stops).\n\n    Args:\n        data (GTFSData): GTFS data object.\n        config (Config): Config object.\n\n    Returns:\n        np.ndarray: [origin id, destination id, walk time, wait time]\n    \"\"\"\n    time_to_distance = config.walk_speed / 3.6  # km/hr to meters\n    max_transfer_distance = config.max_transfer_time * time_to_distance\n    max_wait_distance = config.max_wait * time_to_distance\n\n    # get candidate connectors\n    coords = data.stop_times[[\"x\", \"y\", \"departure_s\"]].values\n    coords[:, :2] = coords[:, :2] * config.crows_fly_factor  # crow's fly transformation\n    tc = TransferConnectors(coords, max_transfer_distance)\n\n    # apply more narrow filters:\n    # enough time to make transfer\n    tc.filter_feasible_transfer(max_transfer_distance)\n\n    # maximum walk\n    if config.walk_distance_threshold &lt; max_transfer_distance:\n        tc.filter_max_walk(config.walk_distance_threshold)\n\n    # maximum wait\n    if max_wait_distance &lt; max_transfer_distance:\n        tc.filter_max_wait(max_wait_distance)\n\n    # not same route\n    routes = data.stop_times[\"trip_id\"].map(data.trips.set_index(\"trip_id\")[\"route_id\"]).values\n    tc.filter_same_route(routes)\n\n    # most efficient transfer to service\n    services = data.stop_times[\"trip_id\"].map(data.trips.set_index(\"trip_id\")[\"service_id\"]).values\n    tc.filter_nearest_service(services)\n\n    # construct array\n    arr = (\n        np.concatenate(\n            [\n                tc.ods,  # origin and destination index\n                (tc.walk / time_to_distance).reshape(-1, 1),  # walk time (seconds)\n                (tc.wait / time_to_distance).reshape(-1, 1),  # wait time (seconds)\n            ],\n            axis=1,\n        )\n        .round(1)\n        .astype(DATA_TYPE)\n    )\n\n    return arr\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.main","title":"<code>main(config, data=None)</code>","text":"<p>Get feasible connections (transfers, access, egress).</p> PARAMETER  DESCRIPTION <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> <code>data</code> <p>GTFS data object. If not provided, reads the stored parquet files from the outputs directory. Defaults to None.</p> <p> TYPE: <code>Optional[GTFSData]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ConnectorsData</code> <p>Connectors object, holding the three output tables.</p> <p> TYPE: <code>ConnectorsData</code> </p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def main(config: Config, data: Optional[GTFSData] = None) -&gt; ConnectorsData:\n    \"\"\"Get feasible connections (transfers, access, egress).\n\n    Args:\n        config (Config): Config object.\n        data (Optional[GTFSData], optional): GTFS data object.\n            If not provided, reads the stored parquet files from the outputs directory.\n            Defaults to None.\n\n    Returns:\n        ConnectorsData: Connectors object, holding the three output tables.\n    \"\"\"\n    logger = get_logger(os.path.join(config.path_outputs, \"log_connectors.log\"))\n\n    if data is None:\n        data = GTFSData.from_parquet(config.path_outputs)\n    origins = pd.read_csv(config.path_origins, index_col=0)\n    destinations = pd.read_csv(config.path_destinations, index_col=0)\n\n    # get feasible connections\n    logger.info(\"Getting transfer connectors...\")\n    connectors_transfer = get_transfer_connectors(data, config)\n    logger.info(\"Getting access connectors...\")\n    connectors_access = get_access_connectors(data, config, origins)\n    logger.info(\"Getting egress connectors...\")\n    connectors_egress = get_egress_connectors(data, config, destinations)\n\n    # convert to dataframe\n    colnames = [\"onode\", \"dnode\", \"walk\", \"wait\"]\n    connectors_transfer = pd.DataFrame(connectors_transfer, columns=colnames)\n    connectors_access = pd.DataFrame(connectors_access, columns=colnames)\n    connectors_egress = pd.DataFrame(connectors_egress, columns=colnames)\n\n    # offset IDs for endpoints\n    connectors_access[\"onode\"] += len(data.stop_times)\n    connectors_egress[\"dnode\"] += len(data.stop_times) + len(origins)\n\n    # save\n    logger.info(f\"Saving connectors to {config.path_outputs}...\")\n    connectors = ConnectorsData(\n        connectors_transfer=connectors_transfer,\n        connectors_access=connectors_access,\n        connectors_egress=connectors_egress,\n    )\n    connectors.save(config.path_outputs)\n\n    return connectors\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.query_pairs","title":"<code>query_pairs(coords, radius)</code>","text":"<p>Get origin-destination pairs between points, within a radius.     The connections are forward-looking in z: ie the destination point         has always greater z coordinate than the origin point.</p> PARAMETER  DESCRIPTION <code>coords</code> <p>Point coordinates (x, y, z)</p> <p> TYPE: <code>ndarray</code> </p> <code>radius</code> <p>Maximum distance between points</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Feasible connections between points.</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def query_pairs(coords: np.ndarray, radius: float) -&gt; np.array:\n    \"\"\"Get origin-destination pairs between points, within a radius.\n        The connections are forward-looking in z: ie the destination point\n            has always greater z coordinate than the origin point.\n\n    Args:\n        coords (np.ndarray): Point coordinates (x, y, z)\n        radius (float): Maximum distance between points\n\n    Returns:\n        np.array: Feasible connections between points.\n    \"\"\"\n    ids = coords[:, 2].argsort()\n\n    dtree = KDTree(coords[ids])\n    connectors = dtree.query_pairs(r=radius, output_type=\"ndarray\", p=2)\n\n    return ids[connectors]\n</code></pre>"},{"location":"reference/gtfs_skims/connectors/#gtfs_skims.connectors.query_pairs_od","title":"<code>query_pairs_od(coords_origins, coords_destinations, radius)</code>","text":"<p>Get origin-destination pairs between points, within a radius.</p> PARAMETER  DESCRIPTION <code>coords_origins</code> <p>Coordinates of origin points</p> <p> TYPE: <code>array</code> </p> <code>coords_destinations</code> <p>Coordinates of destination points</p> <p> TYPE: <code>array</code> </p> <code>radius</code> <p>Maximum distance between points</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>array</code> <p>np.array: Feasible connections between points.</p> Source code in <code>src/gtfs_skims/connectors.py</code> <pre><code>def query_pairs_od(\n    coords_origins: np.ndarray, coords_destinations: np.ndarray, radius: float\n) -&gt; np.array:\n    \"\"\"Get origin-destination pairs between points, within a radius.\n\n    Args:\n        coords_origins (np.array): Coordinates of origin points\n        coords_destinations (np.array): Coordinates of destination points\n        radius (float): Maximum distance between points\n\n    Returns:\n        np.array: Feasible connections between points.\n    \"\"\"\n    tree_origins = KDTree(coords_origins)\n    tree_destinations = KDTree(coords_destinations)\n\n    ods = tree_origins.query_ball_tree(tree_destinations, r=radius)\n\n    # flatten\n    ods = np.column_stack(\n        [np.repeat(range(len(coords_origins)), list(map(len, ods))), np.concatenate(ods)]\n    ).astype(DATA_TYPE)\n\n    return ods\n</code></pre>"},{"location":"reference/gtfs_skims/core/","title":"gtfs_skims.core","text":"<p>Main module.</p>"},{"location":"reference/gtfs_skims/graph/","title":"gtfs_skims.graph","text":""},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.add_gc","title":"<code>add_gc(edges, config)</code>","text":"<p>Calculate generalised time and add it as a column to the 'edges' table.</p> PARAMETER  DESCRIPTION <code>edges</code> <p>Edges dataframe. Should include these columns: ['ivt', 'walk', 'wait', 'transfer']</p> <p> TYPE: <code>DataFrame</code> </p> <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Edges dataframe, with the generalised time (\"gc\") column included.</p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def add_gc(edges: pd.DataFrame, config: Config) -&gt; pd.DataFrame:\n    \"\"\"Calculate generalised time and add it as a column to the 'edges' table.\n\n    Args:\n        edges (pd.DataFrame): Edges dataframe. Should include these columns:\n            ['ivt', 'walk', 'wait', 'transfer']\n        config (Config): Config object.\n\n    Returns:\n        pd.DataFrame: Edges dataframe, with the generalised time (\"gc\") column included.\n    \"\"\"\n    edges[\"gc\"] = (\n        edges[\"ivt\"]\n        + edges[\"walk\"] * config.weight_walk\n        + edges[\"wait\"] * config.weight_wait\n        + edges[\"transfer\"] * config.penalty_interchange\n    )\n\n    # adding unweighted time as well\n    edges[\"time\"] = edges[[\"ivt\", \"walk\", \"wait\"]].sum(1)\n\n    return edges\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.build_graph","title":"<code>build_graph(edges, vars=['ivt', 'walk', 'wait', 'time', 'gc'])</code>","text":"<p>Build a network graph from the edges table.</p> PARAMETER  DESCRIPTION <code>edges</code> <p>Edges table. Should include the 'gc' and 'time' columns from the 'add_gc' method.</p> <p> TYPE: <code>DataFrame</code> </p> <code>vars</code> <p>list of variables to include in the graph as edge properties.</p> <p> TYPE: <code>list</code> DEFAULT: <code>['ivt', 'walk', 'wait', 'time', 'gc']</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>Connected GTFS graph</p> <p> TYPE: <code>Graph</code> </p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def build_graph(edges: pd.DataFrame, vars=[\"ivt\", \"walk\", \"wait\", \"time\", \"gc\"]) -&gt; Graph:\n    \"\"\"Build a network graph from the edges table.\n\n    Args:\n        edges (pd.DataFrame): Edges table. Should include the 'gc' and 'time' columns from the 'add_gc' method.\n        vars (list): list of variables to include in the graph as edge properties.\n\n    Returns:\n        Graph: Connected GTFS graph\n    \"\"\"\n    eprops = [(x, \"int\") for x in vars]\n    g = Graph(edges[[\"onode\", \"dnode\"] + vars].values, hashed=False, eprops=eprops)\n    return g\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.get_all_edges","title":"<code>get_all_edges(gtfs_data, connectors_data)</code>","text":"<p>Get all edges for the accessibility graph.</p> PARAMETER  DESCRIPTION <code>gtfs_data</code> <p>GTFS data object.</p> <p> TYPE: <code>GTFSData</code> </p> <code>connectors_data</code> <p>Connectords data object.</p> <p> TYPE: <code>ConnectorsData</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: ['onode', 'dnode', 'ivt', 'walk', 'wait', 'transfer']</p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def get_all_edges(gtfs_data: GTFSData, connectors_data: ConnectorsData) -&gt; pd.DataFrame:\n    \"\"\"Get all edges for the accessibility graph.\n\n    Args:\n        gtfs_data (GTFSData): GTFS data object.\n        connectors_data (ConnectorsData): Connectords data object.\n\n    Returns:\n        pd.DataFrame: ['onode', 'dnode', 'ivt', 'walk', 'wait', 'transfer']\n    \"\"\"\n    edges = (\n        pd.concat(\n            [\n                get_ivt_edges(gtfs_data.stop_times),\n                connectors_data.connectors_transfer.assign(transfer=1),\n                connectors_data.connectors_access,\n                connectors_data.connectors_egress,\n            ],\n            axis=0,\n        )\n        .fillna(0)\n        .map(int)\n    )\n\n    return edges\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.get_ivt_edges","title":"<code>get_ivt_edges(stop_times)</code>","text":"<p>Get in-vehicle times between stops.</p> PARAMETER  DESCRIPTION <code>stop_times</code> <p>The stoptimes GTFS table.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>np.ndarray: [origin id, destination id, in-vehicle time]</p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def get_ivt_edges(stop_times: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Get in-vehicle times between stops.\n\n    Args:\n        stop_times (pd.DataFrame): The stoptimes GTFS table.\n\n    Returns:\n        np.ndarray: [origin id, destination id, in-vehicle time]\n    \"\"\"\n    edges_ivt = pd.Series(range(len(stop_times)))\n    trip_id = stop_times.reset_index()[\"trip_id\"]\n    departures = stop_times.reset_index()[\"departure_s\"]\n\n    edges_ivt = (\n        pd.concat(\n            [\n                edges_ivt,\n                edges_ivt.groupby(trip_id).shift(-1),\n                departures.groupby(trip_id).shift(-1) - departures,\n            ],\n            axis=1,\n        )\n        .dropna()\n        .map(int)\n    )\n    edges_ivt.columns = [\"onode\", \"dnode\", \"ivt\"]\n\n    return edges_ivt\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.get_shortest_distances","title":"<code>get_shortest_distances(graph, onodes, dnodes, max_dist=None, attribute='gc')</code>","text":"<p>Get shortest distances from a set of origins to a set of destinations.</p> PARAMETER  DESCRIPTION <code>graph</code> <p>GTFS graph.</p> <p> TYPE: <code>Graph</code> </p> <code>onodes</code> <p>Source nodes.</p> <p> TYPE: <code>int</code> </p> <code>dnodes</code> <p>Destination nodes.</p> <p> TYPE: <code>list[int]</code> </p> <code>max_dist</code> <p>Maximum search distance. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>attribute</code> <p>Edge weights attribute. Defaults to 'gc'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'gc'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>pd.DataFrame: Shortest distances matrix. The dataframe indices are the origin nodes, and the column indices are the destination nodes.</p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def get_shortest_distances(\n    graph: Graph,\n    onodes: list[int],\n    dnodes: list[int],\n    max_dist: Optional[float] = None,\n    attribute: str = \"gc\",\n) -&gt; pd.DataFrame:\n    \"\"\"Get shortest distances from a set of origins to a set of destinations.\n\n    Args:\n        graph (Graph): GTFS graph.\n        onodes (int): Source nodes.\n        dnodes (list[int]): Destination nodes.\n        max_dist (Optional[float], optional): Maximum search distance. Defaults to None.\n        attribute (str, optional): Edge weights attribute. Defaults to 'gc'.\n\n    Returns:\n        pd.DataFrame:\n            Shortest distances matrix.\n            The dataframe indices are the origin nodes, and the column indices are the destination nodes.\n    \"\"\"\n    n_cpus = multiprocessing.cpu_count() - 1\n    dist_wrapper = partial(\n        get_shortest_distances_single, graph, dnodes=dnodes, max_dist=max_dist, attribute=attribute\n    )\n    with multiprocessing.Pool(n_cpus) as pool_obj:\n        dists = pool_obj.map(dist_wrapper, onodes)\n\n    dists = np.array(dists)\n    dists = dists[dists[:, 0].argsort()]  # sort by source node\n\n    # convert to dataframe and reindex\n    dists = pd.DataFrame(dists[:, 1:], index=dists[:, 0], columns=dnodes)\n    dists = dists.loc[onodes]\n\n    return dists\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.get_shortest_distances_single","title":"<code>get_shortest_distances_single(graph, onode, dnodes, max_dist=None, attribute='gc')</code>","text":"<p>Get shortest distances from a single origin.</p> PARAMETER  DESCRIPTION <code>graph</code> <p>GTFS graph.</p> <p> TYPE: <code>Graph</code> </p> <code>onode</code> <p>Source node.</p> <p> TYPE: <code>int</code> </p> <code>dnodes</code> <p>Destination nodes.</p> <p> TYPE: <code>list[int]</code> </p> <code>max_dist</code> <p>Maximum search distance. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>attribute</code> <p>Edge weights attribute. Defaults to 'gc'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'gc'</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>np.ndarray: Shortest distances. The first value is the source node.</p> Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def get_shortest_distances_single(\n    graph: Graph,\n    onode: int,\n    dnodes: list[int],\n    max_dist: Optional[float] = None,\n    attribute: str = \"gc\",\n) -&gt; np.ndarray:\n    \"\"\"Get shortest distances from a single origin.\n\n    Args:\n        graph (Graph): GTFS graph.\n        onode (int): Source node.\n        dnodes (list[int]): Destination nodes.\n        max_dist (Optional[float], optional): Maximum search distance. Defaults to None.\n        attribute (str, optional): Edge weights attribute. Defaults to 'gc'.\n\n    Returns:\n        np.ndarray: Shortest distances. The first value is the source node.\n    \"\"\"\n    d = shortest_distance(\n        graph,\n        onode,\n        dnodes,\n        weights=graph.edge_properties[attribute],\n        dense=False,\n        max_dist=max_dist,\n        directed=True,\n    )\n    d = np.concatenate([np.array([onode]), d])\n\n    return d\n</code></pre>"},{"location":"reference/gtfs_skims/graph/#gtfs_skims.graph.main","title":"<code>main(config, gtfs_data=None, connectors_data=None)</code>","text":"Source code in <code>src/gtfs_skims/graph.py</code> <pre><code>def main(\n    config: Config,\n    gtfs_data: Optional[GTFSData] = None,\n    connectors_data: Optional[ConnectorsData] = None,\n) -&gt; pd.DataFrame:\n    # read\n    logger = get_logger(os.path.join(config.path_outputs, \"log_graph.log\"))\n\n    logger.info(\"Reading files...\")\n    if gtfs_data is None:\n        gtfs_data = GTFSData.from_parquet(path=config.path_outputs)\n    if connectors_data is None:\n        connectors_data = ConnectorsData.from_parquet(path=config.path_outputs)\n    origins = pd.read_csv(config.path_origins, index_col=0)\n    destinations = pd.read_csv(config.path_destinations, index_col=0)\n\n    # graph\n    logger.info(\"Building graph...\")\n    edges = get_all_edges(gtfs_data, connectors_data)\n    edges = add_gc(edges=edges, config=config)\n    g = build_graph(edges=edges)\n\n    # shortest paths\n    logger.info(\"Calculating shortest distances...\")\n    origins[\"idx\"] = range(len(origins))\n    origins[\"idx\"] += len(gtfs_data.stop_times)\n    destinations[\"idx\"] = range(len(destinations))\n    destinations[\"idx\"] += len(gtfs_data.stop_times) + len(origins)\n\n    onodes_scope = list(origins[origins[\"idx\"].isin(edges[\"onode\"])][\"idx\"])\n    dnodes_scope = list(destinations[destinations[\"idx\"].isin(edges[\"dnode\"])][\"idx\"])\n    maxdist = config.end_s - config.start_s\n    distmat = get_shortest_distances(g, onodes=onodes_scope, dnodes=dnodes_scope, max_dist=maxdist)\n\n    # expand to the full OD space\n    distmat_full = pd.DataFrame(np.inf, index=origins[\"idx\"], columns=destinations[\"idx\"])\n    distmat_full.loc[distmat.index, distmat.columns] = distmat.values\n\n    # map labels\n    distmat_full.index = distmat_full.index.map(origins.reset_index().set_index(\"idx\")[\"name\"])\n    distmat_full.columns = distmat_full.columns.map(\n        destinations.reset_index().set_index(\"idx\")[\"name\"]\n    )\n\n    # infill intra_zonal\n    distmat_full = distmat_full.apply(lambda x: np.where(x.name == x.index, np.nan, x), axis=0)\n    distmat_full = distmat_full.map(lambda x: np.where(x &gt;= maxdist, np.inf, x))\n\n    # save\n    path = os.path.join(config.path_outputs, \"skims.parquet.gzip\")\n    logger.info(f\"Saving results to {path}...\")\n    distmat_full.to_parquet(path, compression=\"gzip\", index=True)\n\n    return distmat_full\n</code></pre>"},{"location":"reference/gtfs_skims/preprocessing/","title":"gtfs_skims.preprocessing","text":""},{"location":"reference/gtfs_skims/preprocessing/#gtfs_skims.preprocessing.add_coordinates","title":"<code>add_coordinates(data, epsg=27700)</code>","text":"<p>Add BNG coordinates to the stop and stoptime tables.</p> PARAMETER  DESCRIPTION <code>data</code> <p>Data object.</p> <p> TYPE: <code>Data</code> </p> <code>epsg</code> <p>The target coordinate system</p> <p> TYPE: <code>int</code> DEFAULT: <code>27700</code> </p> Source code in <code>src/gtfs_skims/preprocessing.py</code> <pre><code>def add_coordinates(data: GTFSData, epsg: int = 27700) -&gt; None:\n    \"\"\"Add BNG coordinates to the stop and stoptime tables.\n\n    Args:\n        data (Data): Data object.\n        epsg (int): The target coordinate system\n    \"\"\"\n    transformer = pyproj.Transformer.from_crs(\n        pyproj.transformer.CRS(\"epsg:4326\"), pyproj.transformer.CRS(f\"epsg:{epsg}\"), always_xy=True\n    )\n\n    data.stops[\"x\"], data.stops[\"y\"] = transformer.transform(\n        data.stops[\"stop_lon\"], data.stops[\"stop_lat\"]\n    )\n\n    data.stops[\"x\"] = data.stops[\"x\"].round().map(int)\n    data.stops[\"y\"] = data.stops[\"y\"].round().map(int)\n\n    data.stop_times[\"x\"] = data.stop_times[\"stop_id\"].map(data.stops.set_index(\"stop_id\")[\"x\"])\n    data.stop_times[\"y\"] = data.stop_times[\"stop_id\"].map(data.stops.set_index(\"stop_id\")[\"y\"])\n</code></pre>"},{"location":"reference/gtfs_skims/preprocessing/#gtfs_skims.preprocessing.filter_bounding_box","title":"<code>filter_bounding_box(data, xmin, xmax, ymin, ymax)</code>","text":"<p>Filter a GTFS with a bounding box. Coordinates are using the BNG projection.</p> PARAMETER  DESCRIPTION <code>data</code> <p>Data object.</p> <p> TYPE: <code>Data</code> </p> <code>xmin</code> <p>Min Easting.</p> <p> TYPE: <code>int</code> </p> <code>xmax</code> <p>Max Easting.</p> <p> TYPE: <code>int</code> </p> <code>ymin</code> <p>Min Northing.</p> <p> TYPE: <code>int</code> </p> <code>ymax</code> <p>Max Northing</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/gtfs_skims/preprocessing.py</code> <pre><code>def filter_bounding_box(data: GTFSData, xmin: int, xmax: int, ymin: int, ymax: int) -&gt; None:\n    \"\"\"Filter a GTFS with a bounding box. Coordinates are using the BNG projection.\n\n    Args:\n        data (Data): Data object.\n        xmin (int): Min Easting.\n        xmax (int): Max Easting.\n        ymin (int): Min Northing.\n        ymax (int): Max Northing\n    \"\"\"\n    data.stops = data.stops[\n        (data.stops[\"x\"] &gt;= xmin)\n        &amp; (data.stops[\"x\"] &lt;= xmax)\n        &amp; (data.stops[\"y\"] &gt;= ymin)\n        &amp; (data.stops[\"y\"] &lt;= ymax)\n    ]\n\n    # filter stop times\n    data.stop_times = data.stop_times[\n        data.stop_times[\"stop_id\"].isin(set(list(data.stops[\"stop_id\"])))\n    ]\n\n    # filter trips\n    data.trips = data.trips[data.trips[\"trip_id\"].isin(set(data.stop_times[\"trip_id\"]))]\n\n    # filter routes\n    data.routes = data.routes[data.routes[\"route_id\"].isin(set(data.trips[\"route_id\"]))]\n</code></pre>"},{"location":"reference/gtfs_skims/preprocessing/#gtfs_skims.preprocessing.filter_day","title":"<code>filter_day(data, date)</code>","text":"<p>Filter the GTFS for a specific date  in the calendar.</p> PARAMETER  DESCRIPTION <code>data</code> <p>GTFS data object</p> <p> TYPE: <code>Data</code> </p> <code>date</code> <p>Date as yyyymmdd</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/gtfs_skims/preprocessing.py</code> <pre><code>def filter_day(data: GTFSData, date: int) -&gt; None:\n    \"\"\"Filter the GTFS for a specific date  in the calendar.\n\n    Args:\n        data (Data): GTFS data object\n        date (int): Date as yyyymmdd\n    \"\"\"\n    weekday = get_weekday(date)\n    data.calendar = data.calendar[\n        (data.calendar[\"start_date\"] &lt;= date)\n        &amp; (data.calendar[\"end_date\"] &gt;= date)\n        &amp; (data.calendar[weekday] == 1)\n    ]\n\n    data.trips = data.trips[data.trips[\"service_id\"].isin(set(data.calendar[\"service_id\"]))]\n\n    data.routes = data.routes[data.routes[\"route_id\"].isin(set(data.trips[\"route_id\"]))]\n\n    data.stop_times = data.stop_times[data.stop_times[\"trip_id\"].isin(set(data.trips[\"trip_id\"]))]\n\n    data.stops = data.stops[data.stops[\"stop_id\"].isin(set(data.stop_times[\"stop_id\"]))]\n</code></pre>"},{"location":"reference/gtfs_skims/preprocessing/#gtfs_skims.preprocessing.filter_time","title":"<code>filter_time(data, start_time, end_time)</code>","text":"<p>Filter the GTFS for a specified time window.</p> PARAMETER  DESCRIPTION <code>data</code> <p>GTFS data object</p> <p> TYPE: <code>Data</code> </p> <code>start_time</code> <p>Start of the time window (seconds from midnight)</p> <p> TYPE: <code>int</code> </p> <code>end_time</code> <p>End of the time window (seconds from midnight)</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/gtfs_skims/preprocessing.py</code> <pre><code>def filter_time(data: GTFSData, start_time: int, end_time: int) -&gt; None:\n    \"\"\"Filter the GTFS for a specified time window.\n\n    Args:\n        data (Data): GTFS data object\n        start_time (int): Start of the time window (seconds from midnight)\n        end_time (int): End of the time window (seconds from midnight)\n    \"\"\"\n    # filter stop times\n    data.stop_times[\"departure_s\"] = data.stop_times[\"departure_time\"].apply(ts_to_sec)\n    data.stop_times[\"arrival_s\"] = data.stop_times[\"arrival_time\"].apply(ts_to_sec)\n    data.stop_times = data.stop_times[\n        (data.stop_times[\"arrival_s\"] &gt;= start_time) &amp; (data.stop_times[\"departure_s\"] &lt;= end_time)\n    ]\n\n    # filter stops\n    data.stops = data.stops[data.stops[\"stop_id\"].isin(set(data.stop_times[\"stop_id\"]))]\n\n    # filter trips\n    data.trips = data.trips[data.trips[\"trip_id\"].isin(set(data.stop_times[\"trip_id\"]))]\n\n    # filter routes\n    data.routes = data.routes[data.routes[\"route_id\"].isin(set(data.trips[\"route_id\"]))]\n</code></pre>"},{"location":"reference/gtfs_skims/preprocessing/#gtfs_skims.preprocessing.main","title":"<code>main(config)</code>","text":"<p>Run the preprocessing pipeline and save resulting tables to disk.</p> PARAMETER  DESCRIPTION <code>config</code> <p>Config object.</p> <p> TYPE: <code>Config</code> </p> RETURNS DESCRIPTION <code>GTFSData</code> <p>Pre-processed GTFS data object.</p> <p> TYPE: <code>GTFSData</code> </p> Source code in <code>src/gtfs_skims/preprocessing.py</code> <pre><code>def main(config: Config) -&gt; GTFSData:\n    \"\"\"Run the preprocessing pipeline and save resulting tables to disk.\n\n    Args:\n        config (Config): Config object.\n\n    Returns:\n        GTFSData: Pre-processed GTFS data object.\n    \"\"\"\n    logger = get_logger(os.path.join(config.path_outputs, \"log_preprocessing.log\"))\n\n    logger.info(\"Reading files...\")\n    data = GTFSData.from_gtfs(path_gtfs=config.path_gtfs)\n\n    logger.info(\"Time filtering..\")\n    filter_day(data, config.calendar_date)\n    filter_time(data, config.start_s, config.end_s)\n    add_coordinates(data, epsg=config.epsg_centroids)\n\n    if config.bounding_box is not None:\n        logger.info(\"Cropping to bounding box..\")\n        filter_bounding_box(data, **config.bounding_box)\n\n    logger.info(f\"Saving outputs at {config.path_outputs}\")\n    data.save(config.path_outputs)\n\n    logger.info(\"Preprocessing complete.\")\n\n    return data\n</code></pre>"},{"location":"reference/gtfs_skims/utils/","title":"gtfs_skims.utils","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Config file</p> <p>Example config file:</p> <pre><code>paths:\n    path_gtfs: ./iow-bus-gtfs.zip\n    path_outputs: /mnt/efs/otp/gtfs_transfers/skims_iow\n    path_origins: ./centroids.csv # path to the origin points\n    path_destinations: ./centroids.csv # path to the destination points\n\nsettings:\n    calendar_date : 20190515 # yyyymmdd | Date for filtering the GTFS file.\n    start_s : 32400 # sec | Start time of the journey.\n    end_s : 41400 # sec | Max end time of a journey.\n    walk_distance_threshold : 2000  # m | Max walk distance in a leg\n    walk_speed : 4.5  # kph | Walking speed\n    crows_fly_factor : 1.3 # Conversion factor from euclidean to routed distances\n    max_transfer_time : 1800 # Max combined time of walking and waiting (sec)\n    k : 500 # max nearest neighbours when calculating distances\n    max_wait : 1800  # sec | Max wait time at a stop\n    bounding_box : null\n    epsg_centroids: 27700 # coordinate system of the centroids file. Needs to be Cartesian and in meters.\n\n\nsteps:\n- preprocessing\n- connectors\n- graph\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.bounding_box","title":"<code>bounding_box: dict</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.calendar_date","title":"<code>calendar_date: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.crows_fly_factor","title":"<code>crows_fly_factor: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.end_s","title":"<code>end_s: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.epsg_centroids","title":"<code>epsg_centroids: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.max_transfer_time","title":"<code>max_transfer_time: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.max_wait","title":"<code>max_wait: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.path_destinations","title":"<code>path_destinations: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.path_gtfs","title":"<code>path_gtfs: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.path_origins","title":"<code>path_origins: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.path_outputs","title":"<code>path_outputs: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.penalty_interchange","title":"<code>penalty_interchange: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.start_s","title":"<code>start_s: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.steps","title":"<code>steps: list</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.walk_distance_threshold","title":"<code>walk_distance_threshold: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.walk_speed","title":"<code>walk_speed: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.weight_wait","title":"<code>weight_wait: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.weight_walk","title":"<code>weight_walk: float</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Config.from_yaml","title":"<code>from_yaml(path)</code>  <code>classmethod</code>","text":"<p>Construct class from a config yaml file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>Path to the yaml config.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>Config object</p> <p> TYPE: <code>Config</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>@classmethod\ndef from_yaml(cls, path: str) -&gt; Config:\n    \"\"\"Construct class from a config yaml file.\n\n    Args:\n        path (str): Path to the yaml config.\n\n    Returns:\n        Config: Config object\n    \"\"\"\n    with open(path, \"r\") as f:\n        config = yaml.safe_load(f)\n\n    # validate\n    schema = get_schema()\n    jsonschema.validate(config, schema, cls=jsonschema.Draft202012Validator)\n\n    config_flat = {**config[\"paths\"], **config[\"settings\"], \"steps\": config[\"steps\"]}\n    return cls(**config_flat)\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.ConnectorsData","title":"<code>ConnectorsData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Data</code></p>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.ConnectorsData.connectors_access","title":"<code>connectors_access: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.ConnectorsData.connectors_egress","title":"<code>connectors_egress: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.ConnectorsData.connectors_transfer","title":"<code>connectors_transfer: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Data","title":"<code>Data</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Data.from_gtfs","title":"<code>from_gtfs(path_gtfs)</code>  <code>classmethod</code>","text":"<p>Load GTFS tables from a standard zipped GTFS file.</p> PARAMETER  DESCRIPTION <code>path_gtfs</code> <p>Path to a zipped GTFS dataset.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GTFSData</code> <p>GTFS data object.</p> <p> TYPE: <code>Data</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>@classmethod\ndef from_gtfs(cls, path_gtfs: str) -&gt; Data:\n    \"\"\"Load GTFS tables from a standard zipped GTFS file.\n\n    Args:\n        path_gtfs (str): Path to a zipped GTFS dataset.\n\n    Returns:\n        GTFSData: GTFS data object.\n    \"\"\"\n    data = {}\n    with ZipFile(path_gtfs, \"r\") as zf:\n        for name in cls.__annotations__.keys():\n            with zf.open(f\"{name}.txt\") as f:\n                data[name] = pd.read_csv(f, low_memory=False)\n    return cls(**data)\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Data.from_parquet","title":"<code>from_parquet(path)</code>  <code>classmethod</code>","text":"<p>Construct class from pre-processed GTFS tables in Parquet format.</p> PARAMETER  DESCRIPTION <code>path</code> <p>Path to tables.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>GTFSData</code> <p>GTFS data object.</p> <p> TYPE: <code>Data</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>@classmethod\ndef from_parquet(cls, path: str) -&gt; Data:\n    \"\"\"Construct class from pre-processed GTFS tables in Parquet format.\n\n    Args:\n        path (str): Path to tables.\n\n    Returns:\n        GTFSData: GTFS data object.\n    \"\"\"\n    data = {}\n    for name in cls.__annotations__.keys():\n        data[name] = pd.read_parquet(os.path.join(path, f\"{name}.parquet.gzip\"))\n    return cls(**data)\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.Data.save","title":"<code>save(path_outputs)</code>","text":"<p>Export all tables in zipped parquet format.</p> PARAMETER  DESCRIPTION <code>path_outputs</code> <p>Directory to save outputs.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>def save(self, path_outputs: str) -&gt; None:\n    \"\"\"Export all tables in zipped parquet format.\n\n    Args:\n        path_outputs (str): Directory to save outputs.\n    \"\"\"\n    if not os.path.exists(path_outputs):\n        os.makedirs(path_outputs)\n\n    for k, v in self.__dict__.items():\n        v.to_parquet(os.path.join(path_outputs, f\"{k}.parquet.gzip\"), compression=\"gzip\")\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData","title":"<code>GTFSData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Data</code></p>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData.calendar","title":"<code>calendar: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData.routes","title":"<code>routes: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData.stop_times","title":"<code>stop_times: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData.stops","title":"<code>stops: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.GTFSData.trips","title":"<code>trips: pd.DataFrame</code>  <code>instance-attribute</code>","text":""},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.get_logger","title":"<code>get_logger(path_output=None)</code>","text":"<p>Get the library logger.</p> PARAMETER  DESCRIPTION <code>path_output</code> <p>Path to save the logs. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Logger</code> <p>logging.Logger: Logger.</p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>def get_logger(path_output: Optional[str] = None) -&gt; logging.Logger:\n    \"\"\"Get the library logger.\n\n    Args:\n        path_output (Optional[str], optional): Path to save the logs. Defaults to None.\n\n    Returns:\n        logging.Logger: Logger.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    handler.setFormatter(formatter)\n    if len(logger.handlers) == 0:\n        logger.addHandler(handler)\n    else:\n        logger.handlers[0] = handler\n\n    if path_output is not None:\n        parent_dir = Path(path_output).parent.absolute()\n        if not os.path.exists(parent_dir):\n            os.makedirs(parent_dir)\n\n        file_handler = logging.FileHandler(path_output, mode=\"w\")\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    return logger\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.get_schema","title":"<code>get_schema()</code>","text":"<p>Get the config schema.</p> RETURNS DESCRIPTION <code>dict</code> <p>Config yaml file schema.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>def get_schema() -&gt; dict:\n    \"\"\"Get the config schema.\n\n    Returns:\n        dict: Config yaml file schema.\n    \"\"\"\n    path = importlib_resources.files(schema_dir).joinpath(\"schema.yaml\")\n    with open(path, \"r\") as f:\n        schema = yaml.safe_load(f)\n    return schema\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.get_weekday","title":"<code>get_weekday(date)</code>","text":"<p>Get the weekday of a date</p> PARAMETER  DESCRIPTION <code>date</code> <p>Date as yyyymmdd</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Day name</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>def get_weekday(date: int) -&gt; str:\n    \"\"\"Get the weekday of a date\n\n    Args:\n        date (int): Date as yyyymmdd\n\n    Returns:\n        str: Day name\n    \"\"\"\n    weekday = datetime.strptime(str(date), \"%Y%m%d\")\n    weekday = datetime.strftime(weekday, \"%A\").lower()\n    return weekday\n</code></pre>"},{"location":"reference/gtfs_skims/utils/#gtfs_skims.utils.ts_to_sec","title":"<code>ts_to_sec(x)</code>","text":"<p>Convert a hhss timestamp to seconds from midnight.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Timestamp</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Seconds from midnight</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/gtfs_skims/utils.py</code> <pre><code>def ts_to_sec(x: str) -&gt; int:\n    \"\"\"Convert a hh:mm:ss timestamp to seconds from midnight.\n\n    Args:\n        x (str): Timestamp\n\n    Returns:\n        int: Seconds from midnight\n    \"\"\"\n    s = [int(i) for i in x.split(\":\")]\n    return 3600 * s[0] + 60 * s[1] + s[2]\n</code></pre>"},{"location":"reference/gtfs_skims/variables/","title":"gtfs_skims.variables","text":""},{"location":"reference/gtfs_skims/variables/#gtfs_skims.variables.DATA_TYPE","title":"<code>DATA_TYPE = np.uint32</code>  <code>module-attribute</code>","text":""},{"location":"reference/gtfs_skims/variables/#gtfs_skims.variables.ROUTE_TYPES","title":"<code>ROUTE_TYPES = {0: 'tram', 1: 'underground', 2: 'rail', 3: 'bus', 4: 'ferry', 5: 'cable', 6: 'cable aerial', 7: 'furnicular', 11: 'trolley', 12: 'monorail', 200: 'coach', 401: 'undergound', 402: 'underground'}</code>  <code>module-attribute</code>","text":""}]}